<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Space Scene</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      overflow: hidden;
    }
    
    .container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    
    #scene-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .loading-text {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 1.25rem;
      font-family: Arial, sans-serif;
    }
    
    .instruction-text {
      position: absolute;
      bottom: 1rem;
      left: 1rem;
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.875rem;
      font-family: Arial, sans-serif;
      z-index: 100;
      text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
    }
  </style>
  <!-- Import Three.js first -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.150.1/three.min.js"></script>
</head>
<body>
  <div class="container">
    <div id="scene-container"></div>
    <div id="loading-text" class="loading-text">Loading scene...</div>
    <div class="instruction-text">Click and drag to rotate view | Scroll to zoom in/out</div>
  </div>

  <!-- Import OrbitControls after Three.js -->
  <script>
    // Create OrbitControls manually
    // This is a simplified version of OrbitControls
    class OrbitControls {
      constructor(camera, domElement) {
        this.camera = camera;
        this.domElement = domElement;
        this.enableDamping = false;
        this.dampingFactor = 0.05;
        this.rotateSpeed = 1.0;
        this.autoRotate = false;
        this.autoRotateSpeed = 1.0;
        
        // Set initial values
        this.target = new THREE.Vector3();
        this.mouseButtons = { LEFT: THREE.MOUSE.ROTATE };
        this.distance = 15; // Initial zoom distance
        this.minDistance = 3; // Min zoom
        this.maxDistance = 50; // Max zoom
        
        // Event listeners
        this.domElement.addEventListener('mousedown', this.onMouseDown.bind(this), false);
        document.addEventListener('mouseup', this.onMouseUp.bind(this), false);
        document.addEventListener('mousemove', this.onMouseMove.bind(this), false);
        this.domElement.addEventListener('wheel', this.onMouseWheel.bind(this), false);
        
        // Initial state
        this.isMouseDown = false;
        this.mouseX = 0;
        this.mouseY = 0;
        this.targetRotationX = 0;
        this.targetRotationY = 0;
      }
      
      onMouseDown(event) {
        this.isMouseDown = true;
        this.mouseX = event.clientX;
        this.mouseY = event.clientY;
      }
      
      onMouseUp() {
        this.isMouseDown = false;
      }
      
      onMouseMove(event) {
        if (this.isMouseDown) {
          const deltaX = event.clientX - this.mouseX;
          const deltaY = event.clientY - this.mouseY;
          
          this.targetRotationX += deltaX * 0.01 * this.rotateSpeed;
          this.targetRotationY += deltaY * 0.01 * this.rotateSpeed;
          
          // Limit vertical rotation
          this.targetRotationY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.targetRotationY));
          
          this.mouseX = event.clientX;
          this.mouseY = event.clientY;
        }
      }
      
      onMouseWheel(event) {
        event.preventDefault();
        
        // Determine scroll direction and adjust zoom
        const delta = event.deltaY > 0 ? 1 : -1;
        this.distance += delta * 0.5;
        
        // Clamp to min/max distance
        this.distance = Math.max(this.minDistance, Math.min(this.maxDistance, this.distance));
      }
      
      update() {
        if (this.autoRotate) {
          this.targetRotationX += this.autoRotateSpeed * 0.01;
        }
        
        if (this.enableDamping) {
          this.camera.position.x = this.distance * Math.sin(this.targetRotationX) * Math.cos(this.targetRotationY);
          this.camera.position.y = this.distance * Math.sin(this.targetRotationY);
          this.camera.position.z = this.distance * Math.cos(this.targetRotationX) * Math.cos(this.targetRotationY);
        } else {
          this.camera.position.x = this.distance * Math.sin(this.targetRotationX) * Math.cos(this.targetRotationY);
          this.camera.position.y = this.distance * Math.sin(this.targetRotationY);
          this.camera.position.z = this.distance * Math.cos(this.targetRotationX) * Math.cos(this.targetRotationY);
        }
        
        this.camera.lookAt(this.target);
      }
    }
  </script>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Get references to elements
      const sceneContainer = document.getElementById('scene-container');
      const loadingText = document.getElementById('loading-text');
      const containerWidth = window.innerWidth;
      const containerHeight = window.innerHeight;
      
      // Scene setup
      const scene = new THREE.Scene();
      
      // Camera setup
      const camera = new THREE.PerspectiveCamera(
        35,
        containerWidth / containerHeight,
        0.1,
        1000
      );
      camera.position.z = 5;
      
      // Renderer setup
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(containerWidth, containerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      sceneContainer.appendChild(renderer.domElement);
      
      // Background image - use placeholder since the original URL is causing 403 error
      const textureLoader = new THREE.TextureLoader();
      const backgroundTexture = textureLoader.load(
        '/api/placeholder/1920/1080',
        () => {
          // Hide loading text when texture is loaded
          loadingText.style.display = 'none';
        },
        undefined, // onProgress callback not needed
        (error) => {
          // Hide loading text even if there's an error
          console.error('Error loading texture:', error);
          loadingText.style.display = 'none';
        }
      );
      
      // Ensure loading text disappears after a short timeout even if callbacks fail
      setTimeout(() => {
        loadingText.style.display = 'none';
      }, 2000);
      
      scene.background = backgroundTexture;
      
      // Create particle system
      const particleGeometry = new THREE.BufferGeometry();
      const particleCount = 5000;
      
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      
      for (let i = 0; i < particleCount; i++) {
        // Position - create more of a disk shape with particles concentrated in a ring pattern
        const radius = 4 + Math.random() * 8; // Distance from center
        const theta = Math.random() * Math.PI * 2; // Angle around the y-axis
        
        positions[i * 3] = radius * Math.cos(theta); // X position
        positions[i * 3 + 1] = (Math.random() - 0.15) * 2; // Y position (slightly flattened)
        positions[i * 3 + 2] = radius * Math.sin(theta); // Z position
        
        // Color - yellow to red gradient
        // t=0: yellow (1,1,0), t=1: red (1,0,0)
        const t = Math.random();
        colors[i * 3] = 1.0; // R: always full
        colors[i * 3 + 1] = 1.0 - t; // G: fades from 1 to 0
        colors[i * 3 + 2] = 0.0; // B: always zero
      }
      
      particleGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3)
      );
      particleGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(colors, 3)
      );
      
      const particleMaterial = new THREE.PointsMaterial({
        size: 0.03,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
      });
      
      const particles = new THREE.Points(
        particleGeometry,
        particleMaterial
      );
      scene.add(particles);
      
      // Create space objects (planets)
      const createPlanet = (radius, color, x, y, z) => {
        const geometry = new THREE.SphereGeometry(radius, 32, 32);
        const material = new THREE.MeshStandardMaterial({
          color,
          roughness: 0.7,
          metalness: 0.3,
          emissive: 0x331100,
          emissiveIntensity: 0.2
        });
        const planet = new THREE.Mesh(geometry, material);
        planet.position.set(x, y, z);
        scene.add(planet);
        return planet;
      };
      
      // Create main planet with glow
      const mainPlanet = createPlanet(2.5, 0xaa1b22, 0, 0, 0);
      
      // Create a glow effect for the main planet
      const glowGeometry = new THREE.SphereGeometry(2.7, 32, 32);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0xff6600,
        transparent: true,
        opacity: 0.15,
        side: THREE.BackSide
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      glow.position.copy(mainPlanet.position);
      scene.add(glow);
      
      // Add smaller planets/asteroids
      const smallPlanet1 = createPlanet(0.3, 0x442211, 4, 5, 0);
      const smallPlanet2 = createPlanet(0.2, 0x553322, 0, 2, 8);
      const smallPlanet3 = createPlanet(0.15, 0x664433, -3, 6, 3);
      const smallPlanet4 = createPlanet(0.1, 0x775544, 3, -2, -3);
      const smallPlanet5 = createPlanet(0.08, 0x886655, -4,-5, -2);
      
      // Create ring (similar to the image)
    //   const ringGeometry = new THREE.RingGeometry(4, 8, 64);
    //   const ringMaterial = new THREE.MeshBasicMaterial({
    //     color: 0xff7700,
    //     side: THREE.DoubleSide,
    //     transparent: true,
    //     opacity: 0.2,
    //   });
    //   const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    //   ring.rotation.x = Math.PI / 2;
    //   ring.rotation.y = Math.PI / 12;
    //   ring.position.copy(mainPlanet.position);
    //   scene.add(ring);
      
      // Add accretion disk particles
      const diskGeometry = new THREE.BufferGeometry();
      const diskParticleCount = 20000;
      
      const diskPositions = new Float32Array(diskParticleCount * 3);
      const diskColors = new Float32Array(diskParticleCount * 3);
      
      for (let i = 0; i < diskParticleCount; i++) {
        // Create particles in a disk shape with more concentration in the ring
        const radius = 4 + Math.random() * 4; // Between 4 and 8 units
        const theta = Math.random() * Math.PI * 2;
        
        // Position in a flat disk around the main planet
        diskPositions[i * 3] = mainPlanet.position.x + radius * Math.cos(theta);
        diskPositions[i * 3 + 1] = mainPlanet.position.y + (Math.random() - 0.5) * 0.3; // Very thin on y-axis
        diskPositions[i * 3 + 2] = mainPlanet.position.z + radius * Math.sin(theta);
        
        // Color - more reddish-orange for disk particles with distance-based intensity
        const distanceFactor = (radius - 4) / 4; // 0 to 1 based on distance from inner ring
        diskColors[i * 3] = Math.random() * 0.3 + 0.7 - distanceFactor * 0.3; // R: high to medium
        diskColors[i * 3 + 1] = Math.random() * 0.2 * (1 - distanceFactor); // G: low, fades with distance
        diskColors[i * 3 + 2] = 0; // B: none
      }
      
      diskGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(diskPositions, 3)
      );
      diskGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(diskColors, 3)
      );
      
      const diskMaterial = new THREE.PointsMaterial({
        size: 0.03,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
      });
      
      const diskParticles = new THREE.Points(
        diskGeometry,
        diskMaterial
      );
      scene.add(diskParticles);
      
      // Add lights
      const ambientLight = new THREE.AmbientLight(0x111111);
      scene.add(ambientLight);
      
      // Main light source from the right side of the planet (solar light)
      const mainLight = new THREE.PointLight(0xff4400, 2, 20);
      mainLight.position.set(10, 0, 0);
      scene.add(mainLight);
      
      // Secondary glow light for ring illumination
      const secondaryLight = new THREE.PointLight(0xff9900, 1, 15);
      secondaryLight.position.set(5, 2, 5);
      scene.add(secondaryLight);
      
      // Rim light to highlight the edge
      const rimLight = new THREE.PointLight(0xff8800, 1.5, 30);
      rimLight.position.set(5, 0, 0);
      scene.add(rimLight);
      
      // Add a slight bloom effect using a simple technique
      const bloomLight = new THREE.PointLight(0xff3300, 0.5, 10);
      bloomLight.position.copy(mainPlanet.position);
      scene.add(bloomLight);
      
      // Add orbit controls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.005;
      controls.rotateSpeed = 0.05;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.0005;
      
      // Set initial camera position to view the scene properly
      camera.position.set(8, 3, 8);
      controls.update();
      
      // Animation
      const animate = () => {
        requestAnimationFrame(animate);
        
        // Rotate only the particles
        particles.rotation.y += 0.0005;
        
        // Rotate disk particles
        diskParticles.rotation.y += 0.001;
        
        // Keep planets stationary - no rotation
        
        // Keep ring stationary but with slight wobble
        // ring.rotation.z -= 0.0001;
        
        // Pulsate glow slightly
        const time = Date.now() * 0.001;
        glow.material.opacity = 0.1 + Math.sin(time) * 0.05;
        
        // Update controls
        controls.update();
        
        renderer.render(scene, camera);
      };
      
      animate();
      
      // Handle window resize
      const handleResize = () => {
        // Update container dimensions
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // Update camera
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        
        // Update renderer
        renderer.setSize(width, height);
      };
      
      // Add resize listener
      window.addEventListener('resize', handleResize);
    });
  </script>
  
  <!-- OrbitControls for mouse interaction -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</body>
</html>
